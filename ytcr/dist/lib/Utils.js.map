{"version":3,"file":"Utils.js","sourceRoot":"","sources":["../../src/lib/Utils.ts"],"names":[],"mappings":";;;;;AAKA,wCAWC;AAED,wCAcC;AAED,oDAWC;AAED,kDAEC;AAjDD,6DAA6D;AAC7D,aAAa;AACb,8CAAuB;AACvB,4EAAoC;AAEpC,SAAgB,cAAc,CAAC,OAAqB;IAClD,MAAM,KAAK,GAAG,aAAI,CAAC,KAAK,EAAE,CAAC;IAE3B,OAAO,CAAC,IAAI,CAAC,CAAC,MAAM,EAAE,EAAE;QACtB,KAAK,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC;IACxB,CAAC,CAAC;SACC,KAAK,CAAC,CAAC,KAAc,EAAE,EAAE;QACxB,KAAK,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;IACtB,CAAC,CAAC,CAAC;IAEL,OAAO,KAAK,CAAC,OAAO,CAAC;AACvB,CAAC;AAED,SAAgB,cAAc,CAAC,OAAY;IACzC,iEAAiE;IACjE,IAAI,OAAO,OAAO,CAAC,KAAK,KAAK,UAAU,IAAI,OAAO,OAAO,CAAC,IAAI,KAAK,WAAW,EAAE,CAAC;QAC/E,4BAA4B;QAC5B,OAAO,OAAO,CAAC;IACjB,CAAC;IACD,OAAO,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,MAAM,EAAE,EAAE;QACrC,OAAO,CAAC,IAAI,CAAC,CAAC,MAAW,EAAE,EAAE;YAC3B,OAAO,CAAC,MAAM,CAAC,CAAC;QAClB,CAAC,CAAC;aACC,IAAI,CAAC,CAAC,KAAU,EAAE,EAAE;YACnB,MAAM,CAAC,KAAK,YAAY,KAAK,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,KAAK,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;QAChE,CAAC,CAAC,CAAC;IACP,CAAC,CAAC,CAAC;AACL,CAAC;AAED,SAAgB,oBAAoB;IAClC,MAAM,OAAO,GAAG,4BAAE,CAAC,aAAa,CAAC;QAC/B,QAAQ,EAAE,KAAK;QACf,SAAS,EAAE,CAAC;KACb,CAAC,CAAC;IACH,OAAO,OAAO,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,EAAE;QACvB,OAAO;YACL,IAAI,EAAE,CAAC;YACP,EAAE,EAAE,4BAAE,CAAC,IAAI,CAAC,CAAC,EAAE,EAAE,CAAC;SACnB,CAAC;IACJ,CAAC,CAAC,CAAC;AACL,CAAC;AAED,SAAgB,mBAAmB,CAAC,MAAc;IAChD,OAAO,CAAC,CAAC,oBAAoB,EAAE,CAAC,IAAI,CAAC,CAAC,IAAI,EAAE,EAAE,CAAC,IAAI,CAAC,IAAI,KAAK,MAAM,CAAC,CAAC;AACvE,CAAC","sourcesContent":["// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-ignore\nimport libQ from 'kew';\nimport ni from 'network-interfaces';\n\nexport function jsPromiseToKew(promise: Promise<any>): any {\n  const defer = libQ.defer();\n\n  promise.then((result) => {\n    defer.resolve(result);\n  })\n    .catch((error: unknown) => {\n      defer.reject(error);\n    });\n\n  return defer.promise;\n}\n\nexport function kewToJSPromise(promise: any): Promise<any> {\n  // Guard against a JS promise from being passed to this function.\n  if (typeof promise.catch === 'function' && typeof promise.fail === 'undefined') {\n    // JS promise - return as is\n    return promise;\n  }\n  return new Promise((resolve, reject) => {\n    promise.then((result: any) => {\n      resolve(result);\n    })\n      .fail((error: any) => {\n        reject(error instanceof Error ? error : Error(String(error)));\n      });\n  });\n}\n\nexport function getNetworkInterfaces() {\n  const ifNames = ni.getInterfaces({\n    internal: false,\n    ipVersion: 4\n  });\n  return ifNames.map((v) => {\n    return {\n      name: v,\n      ip: ni.toIp(v, {})\n    };\n  });\n}\n\nexport function hasNetworkInterface(ifName: string): boolean {\n  return !!getNetworkInterfaces().find((info) => info.name === ifName);\n}\n"]}