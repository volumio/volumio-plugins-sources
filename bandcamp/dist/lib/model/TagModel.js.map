{"version":3,"file":"TagModel.js","sourceRoot":"","sources":["../../../src/lib/model/TagModel.ts"],"names":[],"mappings":";;;;;AAAA,oEAAqC;AACrC,yEAA0C;AAC1C,4DAAoC;AACpC,8EAAsD;AAEtD,MAAqB,QAAS,SAAQ,mBAAS;IAE7C,KAAK,CAAC,OAAO;QACX,MAAM,IAAI,GAAG,MAAM,yBAAQ,CAAC,QAAQ,EAAE,CAAC,QAAQ,CAC7C,IAAI,CAAC,mBAAmB,CAAC,MAAM,CAAC,EAChC,GAAG,EAAE,CAAC,wBAAO,CAAC,OAAO,CAAC,GAAG,CAAC,IAAI,EAAE,CAAC,CAAC;QAEpC,OAAO;YACL,IAAI,EAAE,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,GAAG,EAAE,EAAE,CAAC,yBAAe,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC;YAC7D,SAAS,EAAE,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC,GAAG,EAAE,EAAE,CAAC,yBAAe,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC;SACxE,CAAC;IACJ,CAAC;IAED,KAAK,CAAC,cAAc,CAAC,IAAc;QACjC,MAAM,OAAO,GAAG,MAAM,yBAAQ,CAAC,QAAQ,EAAE,CAAC,QAAQ,CAChD,IAAI,CAAC,mBAAmB,CAAC,aAAa,EAAE,IAAI,CAAC,EAC7C,GAAG,EAAE,CAAC,wBAAO,CAAC,OAAO,CAAC,GAAG,CAAC,UAAU,CAAC,EAAE,IAAI,EAAE,CAAC,CAAC,CAAC;QAElD,IAAI,OAAO,CAAC;QACZ,IAAI,OAAO,CAAC,KAAK,IAAI,OAAO,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;YAC9C,OAAO,GAAG,OAAO,CAAC,KAAK,CAAC;QAC1B,CAAC;aACI,CAAC;YACJ,OAAO,GAAG,OAAO,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,GAAG,EAAE,EAAE,CAAC,GAAG,CAAC,OAAO,CAAC,MAAM,GAAG,CAAC,CAAC,EAAE,OAAO,CAAC;QAC1E,CAAC;QAED,IAAI,OAAO,IAAI,OAAO,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;YAClC,OAAO,OAAO,CAAC,GAAG,CAAC,CAAC,GAAG,EAAE,EAAE,CAAC,yBAAe,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC,CAAC;QAC/D,CAAC;QACD,OAAO,EAAE,CAAC;IACZ,CAAC;CACF;AA/BD,2BA+BC","sourcesContent":["import bcfetch from 'bandcamp-fetch';\nimport bandcamp from '../BandcampContext';\nimport BaseModel from './BaseModel';\nimport EntityConverter from '../util/EntityConverter';\n\nexport default class TagModel extends BaseModel {\n\n  async getTags() {\n    const tags = await bandcamp.getCache().getOrSet(\n      this.getCacheKeyForFetch('tags'),\n      () => bcfetch.limiter.tag.list());\n\n    return {\n      tags: tags.tags.map((tag) => EntityConverter.convertTag(tag)),\n      locations: tags.locations.map((tag) => EntityConverter.convertTag(tag))\n    };\n  }\n\n  async getRelatedTags(tags: string[]) {\n    const related = await bandcamp.getCache().getOrSet(\n      this.getCacheKeyForFetch('relatedTags', tags),\n      () => bcfetch.limiter.tag.getRelated({ tags }));\n\n    let tagsArr;\n    if (related.combo && related.combo.length > 0) {\n      tagsArr = related.combo;\n    }\n    else {\n      tagsArr = related.single.find((row) => row.related.length > 0)?.related;\n    }\n\n    if (tagsArr && tagsArr.length > 0) {\n      return tagsArr.map((tag) => EntityConverter.convertTag(tag));\n    }\n    return [];\n  }\n}\n"]}