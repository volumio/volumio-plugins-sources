{"version":3,"file":"BaseModel.js","sourceRoot":"","sources":["../../../src/lib/model/BaseModel.ts"],"names":[],"mappings":"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","sourcesContent":["import md5 from 'md5';\n\nexport interface LoopFetchParams<R, I, C extends LoopFetchCallbackParams, E, F extends LoopFetchResult<E>> extends LoopFetchCallbackParams {\n  callbackParams?: C;\n  getFetchPromise: (params: C) => Promise<R>;\n  getItemsFromFetchResult: (fetchResult: R, params: C) => I[];\n  filterFetchedItem?: (item: I, params: C) => boolean;\n  getNextPageTokenFromFetchResult?: (fetchResult: R, params: C) => string | null;\n  convertToEntity: (item: I, params: C) => E | null;\n  onEnd?:(result: LoopFetchResult<E>, lastFetchResult: R, params: C) => F;\n  maxIterations?: number;\n  pageOffset?: number;\n  limit?: number;\n}\n\nexport interface LoopFetchCallbackParams {\n  pageToken?: string;\n}\n\nexport interface LoopFetchResult<E> {\n  items: E[];\n  nextPageToken: string | null;\n  nextPageOffset: number;\n}\n\nexport default class BaseModel {\n\n  async #doLoopFetch<R, I, C extends LoopFetchCallbackParams, E, F extends LoopFetchResult<E>>(\n    params: LoopFetchParams<R, I, C, E, F> & { onEnd: undefined }, currentList?: I[], iteration?: number): Promise<LoopFetchResult<E>>;\n  async #doLoopFetch<R, I, C extends LoopFetchCallbackParams, E, F extends LoopFetchResult<E>>(\n    params: LoopFetchParams<R, I, C, E, F>, currentList?: I[], iteration?: number): Promise<F>;\n  async #doLoopFetch<R, I, C extends LoopFetchCallbackParams, E, F extends LoopFetchResult<E>>(\n    params: LoopFetchParams<R, I, C, E, F>, currentList: I[] = [], iteration = 1): Promise<LoopFetchResult<E> | F> {\n\n    const pageOffset = params.pageOffset || 0;\n    const limit = params.limit || 47;\n    const callbackParams = { ...params.callbackParams } as C;\n    if (params.pageToken) {\n      callbackParams.pageToken = params.pageToken;\n    }\n\n    const fetchResult = await params.getFetchPromise(callbackParams);\n\n    let items = params.getItemsFromFetchResult(fetchResult, callbackParams);\n    if (pageOffset) {\n      items.splice(0, pageOffset);\n    }\n    // Number of items to add before hitting limit\n    const itemCountToLimit = limit - currentList.length;\n\n    let nextPageOffset = 0;\n    const filter = params.filterFetchedItem;\n    if (items.length > 0 && filter) {\n      let itemOffset = 0;\n      let includeCount = 0;\n      const filtered = items.filter((item) => {\n        if (includeCount >= itemCountToLimit) {\n          return false;\n        }\n        const inc = filter(item, callbackParams);\n        if (inc) {\n          includeCount++;\n        }\n        itemOffset++;\n        return inc;\n      });\n      if (itemOffset === items.length) {\n        nextPageOffset = 0;\n      }\n      else {\n        nextPageOffset = itemOffset + pageOffset;\n      }\n      items = filtered;\n    }\n    else if (items) {\n      if (items.length > itemCountToLimit) {\n        items.splice(itemCountToLimit);\n        nextPageOffset = items.length + pageOffset;\n      }\n      else {\n        nextPageOffset = 0;\n      }\n    }\n    currentList = [ ...currentList, ...items ];\n\n    let nextPageToken;\n    if (nextPageOffset > 0 && params.pageToken) {\n      nextPageToken = params.pageToken;\n    }\n    else if (nextPageOffset === 0 && params.getNextPageTokenFromFetchResult) {\n      nextPageToken = params.getNextPageTokenFromFetchResult(fetchResult, callbackParams);\n    }\n    else {\n      nextPageToken = null;\n    }\n\n    iteration++;\n    const maxFetchIterationsReached = params.maxIterations !== undefined && iteration > params.maxIterations;\n    if (!maxFetchIterationsReached && currentList.length < limit && nextPageToken) { // Get more items\n      params.pageToken = nextPageToken;\n      params.pageOffset = 0;\n      return await this.#doLoopFetch(params, currentList, iteration);\n    }\n\n    const result: LoopFetchResult<E> = {\n      items: currentList.reduce<E[]>((reduced, item) => {\n        const entity = params.convertToEntity(item, callbackParams);\n        if (entity) {\n          reduced.push(entity);\n        }\n        return reduced;\n      }, []),\n      nextPageToken: maxFetchIterationsReached ? null : nextPageToken,\n      nextPageOffset: maxFetchIterationsReached ? 0 : nextPageOffset\n    };\n    if (params.onEnd) {\n      return params.onEnd(result, fetchResult, callbackParams);\n    }\n    return result;\n\n  }\n\n  loopFetch<R, I, C extends LoopFetchCallbackParams, E, F extends LoopFetchResult<E>>(params: LoopFetchParams<R, I, C, E, F>) {\n    return this.#doLoopFetch({ ...params });\n  }\n\n  protected getCacheKeyForFetch(resourceName: string, cacheKeyParams?: Record<string, any>) {\n    const prefix = `bandcamp.model.${resourceName}`;\n\n    if (!cacheKeyParams) {\n      return md5(prefix);\n    }\n\n    const key = Object.keys(cacheKeyParams).sort().reduce((s, k) => {\n      const p = `${k}=${encodeURIComponent(JSON.stringify(cacheKeyParams[k]))}`;\n      return `${s}@${p}`;\n    }, prefix);\n\n    return md5(key);\n  }\n\n  protected getAlbumImageFormat() {\n    return 'art_app_large';\n  }\n\n  protected getArtistImageFormat() {\n    return 'bio_app';\n  }\n}\n"]}