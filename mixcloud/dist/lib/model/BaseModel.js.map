{"version":3,"file":"BaseModel.js","sourceRoot":"","sources":["../../../src/lib/model/BaseModel.ts"],"names":[],"mappings":"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","sourcesContent":["import md5 from 'md5';\nimport { CloudcastEntity } from '../entities/CloudcastEntity';\nimport mixcloud from '../MixcloudContext';\n\n/*Export type OptionBundle<T extends any> =\n  T extends { [K in keyof T]: { icon: string; values: any } } ? { [K in keyof T]: OptionBundleEntry<T[K]['values']> } : any;*/\n\nexport type OptionBundle<T extends Record<string, any>> = {\n  [K in keyof T]: OptionBundleEntry<T[K]>;\n};\n\nexport interface OptionBundleEntry<T> {\n  name: string;\n  icon: string;\n  values: { name: string; value: T; }[];\n}\n\nexport interface CommonModelPaginationParams {\n  pageToken?: string;\n  pageOffset?: number;\n  limit: number;\n}\n\nexport interface LoopFetchParams<R, I, C extends LoopFetchCallbackParams, E, F extends LoopFetchResult<E>> extends LoopFetchCallbackParams {\n  callbackParams?: C;\n  getFetchPromise: (params: C) => Promise<R>;\n  getItemsFromFetchResult: (fetchResult: R, params: C) => I[];\n  filterFetchedItem?: (item: I, params: C) => boolean;\n  getNextPageTokenFromFetchResult?: (fetchResult: R, params: C) => string | null;\n  convertToEntity: (item: I, params: C) => E | null;\n  onEnd?:(result: LoopFetchResult<E>, lastFetchResult: R, params: C) => F;\n  maxIterations?: number;\n  pageOffset?: number;\n  limit?: number;\n}\n\nexport interface LoopFetchCallbackParams {\n  pageToken?: string;\n}\n\nexport interface LoopFetchResult<E> {\n  items: E[];\n  nextPageToken: string | null;\n  nextPageOffset: number;\n}\n\nexport default class BaseModel {\n\n  async #doLoopFetch<R, I, C extends LoopFetchCallbackParams, E, F extends LoopFetchResult<E>>(\n    params: LoopFetchParams<R, I, C, E, F> & { onEnd: undefined }, currentList?: I[], iteration?: number): Promise<LoopFetchResult<E>>;\n  async #doLoopFetch<R, I, C extends LoopFetchCallbackParams, E, F extends LoopFetchResult<E>>(\n    params: LoopFetchParams<R, I, C, E, F>, currentList?: I[], iteration?: number): Promise<F>;\n  async #doLoopFetch<R, I, C extends LoopFetchCallbackParams, E, F extends LoopFetchResult<E>>(\n    params: LoopFetchParams<R, I, C, E, F>, currentList: I[] = [], iteration = 1): Promise<LoopFetchResult<E> | F> {\n\n    const pageOffset = params.pageOffset || 0;\n    const limit = params.limit || 47;\n    const callbackParams = { ...params.callbackParams } as C;\n    if (params.pageToken) {\n      callbackParams.pageToken = params.pageToken;\n    }\n\n    const fetchResult = await params.getFetchPromise(callbackParams);\n\n    let items = params.getItemsFromFetchResult(fetchResult, callbackParams);\n    if (pageOffset) {\n      items.splice(0, pageOffset);\n    }\n    // Number of items to add before hitting limit\n    const itemCountToLimit = limit - currentList.length;\n\n    let nextPageOffset = 0;\n    const filter = params.filterFetchedItem;\n    if (items.length > 0 && filter) {\n      let itemOffset = 0;\n      let includeCount = 0;\n      const filtered = items.filter((item) => {\n        if (includeCount >= itemCountToLimit) {\n          return false;\n        }\n        const inc = filter(item, callbackParams);\n        if (inc) {\n          includeCount++;\n        }\n        itemOffset++;\n        return inc;\n      });\n      if (itemOffset === items.length) {\n        nextPageOffset = 0;\n      }\n      else {\n        nextPageOffset = itemOffset + pageOffset;\n      }\n      items = filtered;\n    }\n    else if (items) {\n      if (items.length > itemCountToLimit) {\n        items.splice(itemCountToLimit);\n        nextPageOffset = items.length + pageOffset;\n      }\n      else {\n        nextPageOffset = 0;\n      }\n    }\n    currentList = [ ...currentList, ...items ];\n\n    let nextPageToken;\n    if (nextPageOffset > 0 && params.pageToken) {\n      nextPageToken = params.pageToken;\n    }\n    else if (nextPageOffset === 0 && params.getNextPageTokenFromFetchResult) {\n      nextPageToken = params.getNextPageTokenFromFetchResult(fetchResult, callbackParams);\n    }\n    else {\n      nextPageToken = null;\n    }\n\n    iteration++;\n    const maxFetchIterationsReached = params.maxIterations !== undefined && iteration > params.maxIterations;\n    if (!maxFetchIterationsReached && currentList.length < limit && nextPageToken) { // Get more items\n      params.pageToken = nextPageToken;\n      params.pageOffset = 0;\n      return await this.#doLoopFetch(params, currentList, iteration);\n    }\n\n    const result: LoopFetchResult<E> = {\n      items: currentList.reduce<E[]>((reduced, item) => {\n        const entity = params.convertToEntity(item, callbackParams);\n        if (entity) {\n          reduced.push(entity);\n        }\n        return reduced;\n      }, []),\n      nextPageToken: maxFetchIterationsReached ? null : nextPageToken,\n      nextPageOffset: maxFetchIterationsReached ? 0 : nextPageOffset\n    };\n    if (params.onEnd) {\n      return params.onEnd(result, fetchResult, callbackParams);\n    }\n    return result;\n\n  }\n\n  loopFetch<R, I, C extends LoopFetchCallbackParams, E, F extends LoopFetchResult<E>>(params: LoopFetchParams<R, I, C, E, F>) {\n    return this.#doLoopFetch({ ...params });\n  }\n\n  protected getCacheKeyForFetch(resourceName: string, cacheKeyParams?: Record<string, any>) {\n    const prefix = `mixcloud.model.${resourceName}`;\n\n    if (!cacheKeyParams) {\n      return md5(prefix);\n    }\n\n    const key = Object.keys(cacheKeyParams).sort().reduce((s, k) => {\n      const p = `${k}=${encodeURIComponent(JSON.stringify(cacheKeyParams[k]))}`;\n      return `${s}@${p}`;\n    }, prefix);\n\n    return md5(key);\n  }\n\n  protected cacheCloudcasts(cloudcasts: CloudcastEntity[]) {\n    for (const cloudcast of cloudcasts) {\n      mixcloud.getCache().put(\n        this.getCacheKeyForFetch('cloudcast', { cloudcastId: cloudcast.id }), cloudcast);\n    }\n  }\n}\n"]}